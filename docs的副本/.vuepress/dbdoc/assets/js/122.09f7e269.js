(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{478:function(t,e,a){"use strict";a.r(e);var r=a(42),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"键值数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#键值数据库"}},[t._v("#")]),t._v(" "),a("strong",[t._v("键值数据库")])]),t._v(" "),a("h1",{attrs:{id:"redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Redis")])]),t._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI "),a("a",{attrs:{href:"https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[t._v("C语言"),a("OutboundLink")],1),t._v("编写、支持网络、可基于内存亦可持久化的日志型、Key-Value"),a("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库"),a("OutboundLink")],1),t._v("，并提供多种语言的API。")]),t._v(" "),a("h2",{attrs:{id:"架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.001.png",alt:"1"}})]),t._v(" "),a("h2",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。")]),t._v(" "),a("p",[t._v("2、Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。")]),t._v(" "),a("p",[t._v("3、Redis支持数据的备份，即master-slave模式的数据备份。")]),t._v(" "),a("p",[t._v("4、性能极高 Redis能读的速度是110000次/s,写的速度是81000次/s 。")]),t._v(" "),a("p",[t._v("5、原子 Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。")]),t._v(" "),a("p",[t._v("6、丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。")]),t._v(" "),a("h2",{attrs:{id:"适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：")]),t._v(" "),a("h2",{attrs:{id:"热点数据的缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热点数据的缓存"}},[t._v("#")]),t._v(" "),a("strong",[t._v("热点数据的缓存")])]),t._v(" "),a("p",[t._v("由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。")]),t._v(" "),a("h2",{attrs:{id:"限时业务的运用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限时业务的运用"}},[t._v("#")]),t._v(" "),a("strong",[t._v("限时业务的运用")])]),t._v(" "),a("p",[t._v("redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。")]),t._v(" "),a("h2",{attrs:{id:"计数器相关问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计数器相关问题"}},[t._v("#")]),t._v(" "),a("strong",[t._v("计数器相关问题")])]),t._v(" "),a("p",[t._v("redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。")]),t._v(" "),a("h2",{attrs:{id:"排行榜相关问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排行榜相关问题"}},[t._v("#")]),t._v(" "),a("strong",[t._v("排行榜相关问题")])]),t._v(" "),a("p",[t._v("关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。")]),t._v(" "),a("p",[t._v("在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。")]),t._v(" "),a("h2",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" "),a("strong",[t._v("分布式锁")])]),t._v(" "),a("p",[t._v('这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。')]),t._v(" "),a("p",[t._v("当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。")]),t._v(" "),a("h2",{attrs:{id:"延时操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延时操作"}},[t._v("#")]),t._v(" "),a("strong",[t._v("延时操作")])]),t._v(" "),a("p",[t._v("这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。")]),t._v(" "),a("h2",{attrs:{id:"分页、模糊搜索"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分页、模糊搜索"}},[t._v("#")]),t._v(" "),a("strong",[t._v("分页、模糊搜索")])]),t._v(" "),a("p",[t._v("redis的set集合中提供了一个zrangebylex方法，语法如下：")]),t._v(" "),a("p",[t._v("ZRANGEBYLEX key min max [LIMIT offset count]")]),t._v(" "),a("p",[t._v("通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据")]),t._v(" "),a("p",[t._v("zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。")]),t._v(" "),a("p",[t._v("前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。")]),t._v(" "),a("h2",{attrs:{id:"点赞、好友等相互关系的存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#点赞、好友等相互关系的存储"}},[t._v("#")]),t._v(" "),a("strong",[t._v("点赞、好友等相互关系的存储")])]),t._v(" "),a("p",[t._v("Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。")]),t._v(" "),a("p",[t._v("这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。")]),t._v(" "),a("h2",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" "),a("strong",[t._v("队列")])]),t._v(" "),a("p",[t._v("由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。")]),t._v(" "),a("h1",{attrs:{id:"memcached"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memcached"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Memcached")])]),t._v(" "),a("h2",{attrs:{id:"概述-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。")]),t._v(" "),a("p",[t._v("Memcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款软件。现在已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。")]),t._v(" "),a("p",[t._v("Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。")]),t._v(" "),a("p",[t._v("Memcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。")]),t._v(" "),a("p",[t._v("本质上，它是一个简洁的key-value存储系统。")]),t._v(" "),a("p",[t._v("一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。")]),t._v(" "),a("h2",{attrs:{id:"架构-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.002.png",alt:"2"}})]),t._v(" "),a("h2",{attrs:{id:"特性-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、协议简单")]),t._v(" "),a("p",[t._v("2、基于libevent的事件处理")]),t._v(" "),a("p",[t._v("3、内置内存存储方式")]),t._v(" "),a("p",[t._v("4、memcached不互相通信的分布式")]),t._v(" "),a("h2",{attrs:{id:"适用场景-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("1、数据查询缓存：将数据库中的数据加载到memcached，提供程序的访问速度")]),t._v(" "),a("p",[t._v("2、计数器的场景：通过incr/decr命令实现评论数量、点击数统计、操作次数等等场景")]),t._v(" "),a("p",[t._v("3、乐观锁实现：例如计划任务多实例部署的场景下，通过CAS实现不重复执行。")]),t._v(" "),a("p",[t._v("4、防止重复处理：CAS命令")]),t._v(" "),a("h1",{attrs:{id:"tokyo-tyrant"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tokyo-tyrant"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Tokyo Tyrant")])]),t._v(" "),a("h2",{attrs:{id:"概述-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Tokyo Cabinet 是日本人 平林幹雄 开发的一款 DBM 数据库，该数据库读写非常快。哈希模式下 写入 100 万条数据只需 0.643 秒，读取 100万 条数据只需 0.773秒，是 Berkely DB 等 DBM 的几倍")]),t._v(" "),a("p",[t._v("Tokyo Tyrant 是由同一作者开发的 Tokyo Cabinet 数据库网络接口。它拥有 Memcached 兼容协议，也可以通过 HTTP 协议进行数据交换。")]),t._v(" "),a("p",[t._v("Tokyo Tyrant 加上 Tokyo Cabinet，构成了一款支持高并发的分布式持久存储系统，对任何原有 Memcached客户端来讲，可以将 Tokyo Tyrant 看成是一个 Memcached，但是，它的数据是可以持久存储的。这一点，跟新浪的 Memcached 性质一样。")]),t._v(" "),a("h2",{attrs:{id:"架构-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-3"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.003.png",alt:"20190507093716914"}})]),t._v(" "),a("h2",{attrs:{id:"特性-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-3"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("**1、**故障转移：Tokyo Tyrant 支持双机互为主辅模式，主辅库均可以读写，而 Memcachedb 目前支持类似 MySQL 主辅库同步的方式实现读写分离，支持“主服务器可读写、辅助服务器只读”模式。这里使用 $memcache->addServer 而不是 $memcache->connect 去连接 Tokyo Tyrant 服务器，是因为当 Memcache 客户端使用 addServer 服务器池时，是根据“crc32(key) % current_server_num”哈希算法将 key 哈希到不同的服务器的，PHP、C 和 python 的客户端都是如此的算法。Memcache 客户端的 addserver 具有故障转移机制，当 addserver 了2台 Memcached 服务器，而其中1台宕机了，那么 current_server_num 会由原先的2变成1。")]),t._v(" "),a("p",[t._v("2、日志文件体积小：Tokyo Tyrant 用于主辅同步的日志文件比较小，大约是数据库文件的1.3倍，而 Memcachedb 的同步日志文件非常大，如果不定期清理，很容易将磁盘写满。")]),t._v(" "),a("p",[t._v("3、超大数据量下表现出色：")]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.004.png",alt:"20190507094155704"}})]),t._v(" "),a("p",[t._v("推荐在64位 CPU、操作系统上安装运行。")]),t._v(" "),a("h1",{attrs:{id:"flare"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flare"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Flare")])]),t._v(" "),a("h2",{attrs:{id:"概述-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Flare简单的说就是给TC添加了scale功能。他替换掉了TT部分，自己另外给TC写了网络服务器，Flare的主要特点就是支持scale能力，他在网络服务端之前添加了一个node server，来管理后端的多个服务器节点，因此可以动态添加数据库服务节点，删除服务器节点，也支持failover。如果你的使用场景必须要让TC可以scale，那么可以考虑flare。")]),t._v(" "),a("h2",{attrs:{id:"架构-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-4"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("h2",{attrs:{id:"特性-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-4"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、持久存储；")]),t._v(" "),a("p",[t._v("2、可插拔存储；")]),t._v(" "),a("p",[t._v("3、数据复制(同步或异步)；")]),t._v(" "),a("p",[t._v("4、数据分区；")]),t._v(" "),a("p",[t._v("5、动态重构和分区；")]),t._v(" "),a("p",[t._v("6、节点监视和故障转移；")]),t._v(" "),a("p",[t._v("7、请求代理；")]),t._v(" "),a("p",[t._v("8、flare的key可以超过256bytes,而value可以超过1mb。 传统memcached由于内存分配策略因此有上述限制。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-3"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("1、最正统的就是key/value storage。我自己将flare作为doggy中dhash的后端实现。")]),t._v(" "),a("p",[t._v("2.、Session Storage。 比如PHP，可以直接适用memcached的session_handler。由于是持久的，因此解决原来memcached的尴尬和困扰。")]),t._v(" "),a("p",[t._v("\\3. 其他的基于key/value的扩展方案")]),t._v(" "),a("p",[t._v("Flare可以直接替代Memcached么？")]),t._v(" "),a("p",[t._v("答案是否。Flare的优势和本质是分布式key/value的持久存储，而不是作为一个cache。作为一个caching方案，要比memcached差很多。尤其是启用了binary protocol后，memcached的优势很明显")]),t._v(" "),a("h1",{attrs:{id:"roma"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#roma"}},[t._v("#")]),t._v(" "),a("strong",[t._v("ROMA")])]),t._v(" "),a("h2",{attrs:{id:"概述-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-5"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("ROMA是用于分布式键值存储的数据存储系统之一。它是一个完全分散的分布式系统，由多台机器上称为节点的多个进程组成。它基于像分布式哈希表这样的纯P2P体系结构，因此提供了高可用性和可伸缩性。")]),t._v(" "),a("h2",{attrs:{id:"架构-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-5"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("h2",{attrs:{id:"特性-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-5"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("ROMA用Ruby编写。但是，可以使用以下选择来访问ROMA。")]),t._v(" "),a("p",[t._v("1、提供了Ruby和Java的客户端库。")]),t._v(" "),a("p",[t._v("2、ROMA协议与基于文本的Memcached协议兼容，因此任何Memcached客户端库都允许用户与ROMA进行交互。")]),t._v(" "),a("h1",{attrs:{id:"berkeley"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#berkeley"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Berkeley")])]),t._v(" "),a("h2",{attrs:{id:"概述-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-6"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Berkeley DB (DB)是一个高性能的，嵌入数据库编程库，和C语言，C++，Java，Perl，Python，PHP，Tcl以及其他很多语言都有绑定。Berkeley DB可以保存任意类型的键/值对，而且可以为一个键保存多个数据。Berkeley DB可以支持数千的并发线程同时操作数据库，支持最大256TB的数据")]),t._v(" "),a("h2",{attrs:{id:"架构-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-6"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.005.jpeg",alt:"2"}})]),t._v(" "),a("h2",{attrs:{id:"特性-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-6"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、访问速度快；")]),t._v(" "),a("p",[t._v("2、省硬盘空间；")]),t._v(" "),a("p",[t._v("3、Berkeley DB只支持单一的数据结构，它的所有数据包括两个部分：key和data；")]),t._v(" "),a("p",[t._v("4、Berkeley DB原则上是为"),a("a",{attrs:{href:"https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/6484152",target:"_blank",rel:"noopener noreferrer"}},[t._v("嵌入式数据库"),a("OutboundLink")],1),t._v("设计的。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-4"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("Berkeley DB是一个Embeddable database即嵌入式数据库，是说它是作为一个库来链接到你的应用程序的可执行文件的，你的程序中调用它的API来与它进行交流，没有SQL语言，没有数据库连接；并不是说它只能用在嵌入式系统上面。事实上，有很大一部分Berkeley DB的用户是在 *nix 服务器上使用它，虽然它也支持很多种嵌入式系统，比如VxWorks, QNX, BREW, S60, WinCE等，并且在将来会支持更多。由于它链接到程序中成为其中的一部分，访问数据库功能就省去了网络连接和数据传输开销(HA例外), 因而速度快了很多。")]),t._v(" "),a("h1",{attrs:{id:"memlink"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memlink"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Memlink")])]),t._v(" "),a("h2",{attrs:{id:"概述-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-7"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Memlink是一个高性能、持久化、分布式的Key=>List/Queue数据引擎。正如名称中的Mem所示，所有数据都建构在内存中，保证了系统的高性能，同时使用块链进行内存压缩，使用redo-log技术保证数据的持久化。此外，Memlink还支持主从复制、读写分离、数据项过滤操作等功能。")]),t._v(" "),a("h2",{attrs:{id:"架构-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-7"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.006.png",alt:"3"}})]),t._v(" "),a("h2",{attrs:{id:"特性-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-7"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、内存数据引擎，性能极为高效；")]),t._v(" "),a("p",[t._v("2、List中的Node采用块链组织，精简内存，优化查找效率；")]),t._v(" "),a("p",[t._v("3、Node数据项可定义Mask表，支持多种过滤操作；")]),t._v(" "),a("p",[t._v("4、支持redo-log，数据持久化，非Cache模式；")]),t._v(" "),a("p",[t._v("5、分布式，主从同步；")]),t._v(" "),a("p",[t._v("6、读写分离，写优先处理。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-5"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("Memlink是专注于Key => List/Queue对象的存储系统，它内存使用更精简、性能更高效。 Key => List/Queue系统作为Key => Value另一种形式补充，为高性能、海量数据的Web应用提供了新的数据存储模型选择。")]),t._v(" "),a("h1",{attrs:{id:"tair"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tair"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Tair")])]),t._v(" "),a("h2",{attrs:{id:"tair-性能增强型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tair-性能增强型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Tair("),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/126164.htm?spm=a2c63.p38356.879954.3.4b024c65WpFagE#concept-1254543",title:"Redis企业版性能增强型（简称性能增强型）适合并发量大、读写热点多，对性能的要求超过云Redis社区版实例的场景。相比云数据库Redis社区版，企业版的性能增强型主要多线程性能增强和多模块集成方面进行了优化。",target:"_blank",rel:"noopener noreferrer"}},[t._v("性能增强型"),a("OutboundLink")],1),t._v(")")])]),t._v(" "),a("h2",{attrs:{id:"概述-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-8"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("Redis企业版性能增强型（简称性能增强型）适合并发量大、读写热点多，对性能的要求超过云Redis社区版实例的场景。相比云数据库Redis社区版，企业版的性能增强型主要多线程性能增强和多模块集成方面进行了优化。")]),t._v(" "),a("h2",{attrs:{id:"架构-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-8"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.007.png",alt:"1616465760(1)"}})]),t._v(" "),a("h2",{attrs:{id:"特性-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-8"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、100%兼容原生Redis，无需修改业务代码。")]),t._v(" "),a("p",[t._v("2、读写性能达到同规格原生Redis或者云Redis社区版实例的3倍，能够突破热点数据高频读写受到的性能限制。")]),t._v(" "),a("p",[t._v("3、相比原生Redis，高QPS场景下响应时间更低，性能表现更佳。")]),t._v(" "),a("p",[t._v("4、在大并发场景下运行稳定，可以极大地缓解突发大量请求导致的连接问题，从容应对业务高峰。")]),t._v(" "),a("p",[t._v("5、全量同步和增量同步在IO线程中进行，提高同步速度。")]),t._v(" "),a("p",[t._v("6、支持标准、集群和读写分离部署架构。")]),t._v(" "),a("p",[t._v("7、集成多个自研的Redis模块，包括："),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/145902.htm#concept-2353550",title:"本章节介绍TairString数据支持的命令。",target:"_blank",rel:"noopener noreferrer"}},[t._v("TairString"),a("OutboundLink")],1),t._v("、"),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/145970.htm#concept-2353551",title:"本文介绍TairHash数据支持的命令。",target:"_blank",rel:"noopener noreferrer"}},[t._v("TairHash"),a("OutboundLink")],1),t._v("、"),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/145971.htm#concept-2353552",title:"本章节介绍TairGIS数据支持的命令。",target:"_blank",rel:"noopener noreferrer"}},[t._v("TairGIS"),a("OutboundLink")],1),t._v("、"),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/145972.htm#concept-2353553",title:"本章节介绍TairBloom数据支持的命令。",target:"_blank",rel:"noopener noreferrer"}},[t._v("TairBloom"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"https://www.alibabacloud.com/help/zh/doc-detail/145940.htm#concept-2353554",title:"本章节介绍TairDoc数据支持的命令。",target:"_blank",rel:"noopener noreferrer"}},[t._v("TairDoc"),a("OutboundLink")],1),t._v("，扩展了Redis的适用性，同时降低了复杂场景下业务的开发难度，让您专注于业务创新。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-6"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("适用于视频直播、电商秒杀和在线教育等场景，下面列举了性能增强型在4个典型场景中的应用。")]),t._v(" "),a("p",[t._v("场景1：使用Redis社区版的标准版-双副本实例在秒杀场景中构建缓存，部分热点Key的QPS要求高达20万以上，社区版实例无法满足业务高峰期的需求。")]),t._v(" "),a("p",[t._v("采用性能增强型（标准架构）实例后，热门商品秒杀过程流畅，未发生性能问题。")]),t._v(" "),a("p",[t._v("场景2：在业务中使用云Redis社区版集群实例，但在使用事务和Lua脚本功能时有一定的限制。")]),t._v(" "),a("p",[t._v("采用性能增强型实例后，在满足性能需求的同时消除了集群版的命令使用限制。")]),t._v(" "),a("p",[t._v("场景3：自建有一主多备的Redis服务，随着业务中访问量的不断提高，备节点数量也要随之增加，管理维护成本越来越高。")]),t._v(" "),a("p",[t._v("采用具备一个数据节点五个只读副本的性能增强型（读写分离架构）实例后，可以轻松应对百万级QPS的业务挑战。")]),t._v(" "),a("p",[t._v("场景4：自建有Redis集群来承担线上千万级QPS的业务压力。随着业务的发展，Redis分片数不断增加，管理维护成本居高不下。")]),t._v(" "),a("p",[t._v("采用性能增强型（集群架构）实例后，集群规模缩到原来的三分之一，管理维护成本大幅降低。")]),t._v(" "),a("h2",{attrs:{id:"tair-混合存储型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tair-混合存储型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Tair(混合存储型)")])]),t._v(" "),a("h2",{attrs:{id:"概述-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-9"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("云数据库Redis企业版混合存储型。与社区版Redis不同，混合存储型整合了内存和磁盘二者的优势，在提供高速数据读写能力的同时满足了数据持久化的需求。")]),t._v(" "),a("h2",{attrs:{id:"架构-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-9"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.008.png",alt:"p52674"}})]),t._v(" "),a("h2",{attrs:{id:"特性-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-9"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("Redis企业版混合存储型（简称混合存储型）是阿里云自主研发的兼容Redis协议的混合存储产品，使用磁盘存储全量数据，将热数据保存到内存中供应用快速读写。在保证常用数据访问性能不下降的基础上，混合存储型能够大幅度降低用户成本，实现性能与成本的平衡，同时使单个Redis实例的数据量不再受内存大小的限制。")]),t._v(" "),a("p",[t._v("内存数据：内存中存放了热数据的Key和Value，同时为快速确认要操作的Key是否存在，内存中也会缓存所有的Key信息。")]),t._v(" "),a("p",[t._v("磁盘数据：磁盘中存放所有的Key和Value，Redis的数据结构（例如Hash）也会以一定的格式进行存储在磁盘。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-7"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("视频直播 视频直播类业务往往存在大量热点数据，大部分的请求都来自于热门的直播间。使用混合存储型，内存中保留热门直播间的数据，不活跃的直播间数据被自动存储到磁盘上，可以达到对有限内存的最佳利用效果。")]),t._v(" "),a("p",[t._v("电子商务 电商类应用往往有大量的商品数据。使用混合存储型可以轻松突破内存容量限制，将大量的商品数据都存储到混合存储型中。在正常业务请求中，活跃的商品数据会保留在内存，不活跃的商品数据会逐渐交换到磁盘上，从而解决内存不够的问题。")]),t._v(" "),a("p",[t._v("在线教育 在线教育类的场景有大量的课程、题库以及师生交流信息等数据，通常只有热门课程和最新题库会被频繁访问。使用混合存储型，将所有课程信息存储到磁盘，访问量大的课程和题库数据存储到内存并常驻内存，保证高频访问数据的读写性能，实现高性能与高性价比的有机结合。")]),t._v(" "),a("p",[t._v("典型业务场景的示例如下：")]),t._v(" "),a("p",[t._v("场景1：使用开源Redis集群存储了100GB的数据，但高峰期QPS不到2万，其中80%的数据的访问频率很低。")]),t._v(" "),a("p",[t._v("使用32GB内存加128GB磁盘的混合存储型实例后，节省了近70GB的内存空间，存储成本下降50%以上。")]),t._v(" "),a("p",[t._v("场景2：在IDC自建Pika实例来解决Redis存储成本高的问题。总数据量约400GB，其中访问频率高的数据仅占10%左右，并且集群的运维成本居高不下。")]),t._v(" "),a("p",[t._v("使用64GB内存加512GB磁盘的混合存储型实例后，既免除了繁重的运维工作，又保障了服务质量。")]),t._v(" "),a("h1",{attrs:{id:"etcd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etcd"}},[t._v("#")]),t._v(" "),a("strong",[t._v("etcd")])]),t._v(" "),a("h2",{attrs:{id:"概述-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-10"}},[t._v("#")]),t._v(" "),a("strong",[t._v("概述")])]),t._v(" "),a("p",[t._v("etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，etcd基于Go语言实现。")]),t._v(" "),a("h2",{attrs:{id:"架构-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构-10"}},[t._v("#")]),t._v(" "),a("strong",[t._v("架构")])]),t._v(" "),a("p",[a("img",{attrs:{src:"Aspose.Words.c9f17846-4b76-4cf3-af40-64ccbc0b8421.009.jpeg",alt:"v2-87adbac969e187939a2dcd1ff0aa54c7_1440w"}})]),t._v(" "),a("h2",{attrs:{id:"特性-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-10"}},[t._v("#")]),t._v(" "),a("strong",[t._v("特性")])]),t._v(" "),a("p",[t._v("1、简单：安装配置简单，而且提供了HTTP API进行交互，使用也很简单")]),t._v(" "),a("p",[t._v("2、安全：支持SSL证书验证")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("快速：根据官方提供的benchmark数据，单实例支持每秒2k+读操作")])]),t._v(" "),a("p",[t._v("4、可靠：采用raft算法，实现分布式系统数据的可用性和一致性。")]),t._v(" "),a("h2",{attrs:{id:"适用场景-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-8"}},[t._v("#")]),t._v(" "),a("strong",[t._v("适用场景")])]),t._v(" "),a("p",[t._v("etcd比较多的应用场景是用于服务发现，服务发现(Service Discovery)要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务如何才能找到对方并建立连接。")]),t._v(" "),a("p",[t._v("从本质上说，服务发现就是要了解集群中是否有进程在监听upd或者tcp端口，并且通过名字就可以进行查找和链接。")]),t._v(" "),a("p",[t._v("要解决服务发现的问题，需要下面三大支柱，缺一不可。")]),t._v(" "),a("p",[t._v("一个强一致性、高可用的服务存储目录。")]),t._v(" "),a("p",[t._v("基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。")]),t._v(" "),a("p",[t._v("一种注册服务和健康服务健康状况的机制。")]),t._v(" "),a("p",[t._v("用户可以在etcd中注册服务，并且对注册的服务配置key TTL，定时保持服务的心跳以达到监控健康状态的效果。")]),t._v(" "),a("p",[t._v("一种查找和连接服务的机制。")]),t._v(" "),a("p",[t._v("通过在etcd指定的主题下注册的服务业能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个proxy模式的etcd，这样就可以确保访问etcd集群的服务都能够互相连接。")]),t._v(" "),a("h2",{attrs:{id:"数据库对比图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库对比图"}},[t._v("#")]),t._v(" "),a("strong",[t._v("数据库对比图")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}}),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Memcached")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Redis")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Tokyo Tyrant")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Berkeley")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Memlink")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("etcd")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("是否开源")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("持久化")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("分布式")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("数据类型")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("key/value")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("String、Hash、List、Set、Sorted Set")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("key/value")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("key/value")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("key-list/queue")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("p"),a("p",[t._v("key/value")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("嵌入式")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")])])])]),t._v(" "),a("h2",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" "),a("strong",[t._v("参考文献")])]),t._v(" "),a("p",[a("a",{attrs:{href:"http://memcached.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://memcached.org"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://redis.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://redis.io"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://etcd.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://etcd.io/"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=v.exports}}]);